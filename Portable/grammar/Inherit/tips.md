1.基类有带参数构造函数且没有默认构造函数：派生类必须显式调用基类的带参数构造函数。

2.基类有默认构造函数：派生类可以选择不显式调用基类的构造函数，因为编译器会自动调用基类的默认构造函数。

3.虚类特点
    包含纯虚函数：至少有一个纯虚函数（没有实现体，只有声明），这样的类称为抽象类。
    不能被实例化：不能创建抽象类的对象。
    用作基类：抽象类被用作其他类的基类，派生类必须实现所有的纯虚函数才能被实例化。

4.虚函数的重写：派生类可以重写基类的虚函数，通过 override 关键字可以明确地声明这种重写关系，但即使没有使用 override，只要函数的签名一致，语义上仍然属于重写。
            Map* Bp = new SchoolMap(1, 1, 100, 100);
            Bp->getinfo();
            delete Bp; // 删除对象，释放内存
                [100%] Built target program
                Running project...
                SchoolMap class

5.函数标签不同，属于重载
    基类和派生类之间的重载：函数名称相同但参数列表不同的函数，在基类和派生类之间形成重载关系。这种情况下的函数调用是静态绑定的。
    普通函数之间的重载：在同一作用域中，函数名称相同但参数列表不同的函数形成重载关系。这种情况下的函数调用也是静态绑定的。

6.继承方式对应访问权限
    继承方式	    基类的public成员	    基类的protected成员	    基类的private成员	    继承引起的访问控制关系变化概括
    public继承	    仍为public成员	        仍为protected成员	        不可见	                基类的非私有成员在子类的访问属性不变
    protected继承	变为protected成员	    变为protected成员	        不可见	                基类的非私有成员都为子类的保护成员
    private继承	    变为private成员	        变为private成员	            不可见	                基类中的非私有成员都称为子类的私有成员